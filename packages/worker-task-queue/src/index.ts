/**
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

interface TaskQueueOptions extends WorkerOptions {
  size?: number;
}

type TaskId = number;

type WorkerId = number;

const enum Status {
  RESOLVE,
  REJECT
}

const enum Options {
  LAZY,
  EAGER
}

type TaskResultDesc = [TaskId, Status, any?];

// interface WorkerTaskQueue {
//   postTask<T>(taskName: string, ...args: any[]): Task<T>;
// }

interface WorkerTaskQueue {
  $$pool: TaskQueuePool;
}

class WorkerTaskQueue {
  constructor(workerUrl: string, options?: TaskQueueOptions) {
    const size = (options && Number(options.size)) || 1;
    const pool = new TaskQueuePool(size, workerUrl, options);
    prop(this, '$$pool', pool);
  }

  postTask<T>(taskName: string, ...args: any[]) {
    const task = new Task<T>();
    task.id = ++COUNT;
    this.$$pool.exec(task, taskName, args);
    prop(task, '$$queue', this);
    return task;
  }

  destroy() {
    this.$$pool.destroy();
  }
}

export default WorkerTaskQueue;

// export default WorkerTaskQueue;

// All IDs are generated by incrementing a shared counter
let COUNT = 0;

// used to verify that a task was serialized by TaskQueuePool
const SPECIAL = '$' + Math.random().toString(36).substring(2);

type Walker = (value: Task<any>, i: string | number, parent: object) => void;

function walkTaskArgs(obj: object, walker: Walker) {
  for (let i in obj) {
    const value = obj[i];
    if (typeof value === 'object' && value) {
      if (value instanceof Task) {
        walker(value, i, obj);
      } else {
        walkTaskArgs(value, walker);
      }
    }
  }
}

function prop(obj: object, key: string, value: any) {
  Object.defineProperty(obj, key, { value });
}

interface TaskWorker extends Worker {
  id: WorkerId;
  pending: number;
  ready: Promise<void>;
  call<T = any>(method: string, args: any[]): Promise<T>;
}

type PromiseController<T = any, E = any> = {
  [Status.RESOLVE]: (value: T) => void;
  [Status.REJECT]: (error: E) => void;
};

interface ResultController<T = any> extends PromiseController {
  /** is the task waiting to be sent to a worker? */
  pending: boolean;
  /** has the task been cancelled? */
  cancelled: boolean;
  /* has the task been marked as completed by its worker? */
  completed: boolean;
  /* has the task result been obtained from the worker? */
  fulfilled: boolean;
  /* has the task result been requested from the worker? */
  requested: boolean;
  result: Promise<T>;
}

interface TaskQueuePool {
  poolSize: number;
  workerUrl: string;
  workerOptions?: WorkerOptions;
  workers: TaskWorker[];
  tasks: Record<number, Task<any>>;
  results: Record<number, ResultController>;
  workerTaskAssignments: Record<TaskId, WorkerId>;
}

class TaskQueuePool {
  constructor(
    poolSize: number,
    workerUrl: string,
    workerOptions?: WorkerOptions
  ) {
    this.poolSize = poolSize;
    this.workerUrl = workerUrl;
    this.workerOptions = workerOptions;
    this.workers = [];
    this.tasks = {};
    this.results = {};
    this.workerTaskAssignments = {};
  }

  destroy() {
    const tasks = this.tasks;
    for (let id in tasks) {
      this.cancel(id as any as number);
    }
    let worker;
    while (worker = this.workers.pop()) worker.terminate();
  }

  exec<T = any>(task: Task<T>, taskName: string, args: any[]) {
    const worker = this.getTaskWorker(taskName, args) || this.getNextWorker();
    this.workerTaskAssignments[task.id] = worker.id;
    this.tasks[task.id] = task;
    task.state = 'scheduled';
    worker.pending++;

    let resolve, reject;
    const result = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });

    const resultController: ResultController = {
      pending: true,
      cancelled: false,
      completed: false,
      fulfilled: false,
      requested: false,
      result,
      [Status.RESOLVE]: resolve,
      [Status.REJECT]: reject
    };

    this.results[task.id] = resultController;

    const tasksToResolveIndices = [];
    const tasksToResolve = [];
    const tasks = [];

    // @TODO it would be better to serialize tasks to their $$taskIdentifier String representation here.
    // However doing so cannot mutate args in-place, as it would reveal the identifier secret.
    walkTaskArgs(args, (value) => {
      if (this.getWorkerForTask(value.id) !== worker) {
        const resultController = this.results[value.id];
        console.warn(
          `Task#${value.id} passed to ${taskName}[${
            task.id
          }] was invoked in a different context. The result will be ${
            resultController.fulfilled ? '' : 'materialized & '
          }transferred.`
        );
        tasksToResolveIndices.push(tasks.length);
        tasksToResolve.push(resultController.result);
      }
      tasks.push(value);
    });

    // also wait for the worker to be loaded (async module resolution, etc)
    tasksToResolve.push(worker.ready);

    Promise.all(tasksToResolve)
      .then((taskValues) => {
        resultController.pending = false;
        if (resultController.cancelled) return;

        for (let i = tasks.length; i--; ) {
          const task = tasks[i];
          task.$$taskIdentifier = SPECIAL + ':' + task.id;
        }

        for (let i = tasksToResolveIndices.length; i--; ) {
          const task = tasks[tasksToResolveIndices[i]];
          task.$$taskResult = taskValues[i];
        }

        let options: Options = Options.LAZY;
        // if we need a result right away, mark the task as requiring a return
        // value. This handles common cases like `await q.postTask().result`.
        if (resultController.requested) {
          options |= Options.EAGER;
        }
        worker.call('task', [task.id, options, taskName].concat(args));
      })
      .then(() => {
        for (let i = 0; i < tasks.length; i++) {
          delete tasks[i].$$taskIdentifier;
          delete tasks[i].$$taskResult;
        }
      });
  }

  /**
   * Cancel a task by its ID.
   * Cancellation is not guaranteed, since task may already have started executing.
   * Cancelling an already-completed task returns `false`.
   */
  cancel(taskId: number): boolean | void {
    const task = this.tasks[taskId];
    const resultController = this.results[taskId];
    if (resultController.completed || task.state === 'completed') {
      return false;
    }

    task.state = 'cancelled';
    resultController.cancelled = true;
    if (!resultController.pending) {
      const workerId = this.workerTaskAssignments[taskId];
      const worker = this.getWorker(workerId);
      worker.call('cancel', [taskId]);
    }
  }

  /**
   * Returns a Promise that will be fulfilled with the Task's value/error.
   */
  getResult(taskId: number) {
    const resultController = this.results[taskId];
    if (!resultController) {
      // this should never happen!
      throw Error(`Unknown result for Task: ${taskId}`);
    }
    if (resultController.pending === true) {
      resultController.requested = true;
    } else if (
      resultController.fulfilled === false &&
      resultController.requested === false
    ) {
      resultController.requested = true;
      const workerId = this.workerTaskAssignments[taskId];
      const worker = this.getWorker(workerId);
      worker.call('getresult', [taskId]);
    }
    return resultController.result;
  }

  freeWorkerTask(worker: TaskWorker) {
    if (--worker.pending === 0) {
      // @todo: the worker now has no pending tasks.
      // Should we reallocate any pending idempotent tasks from other workers in the pool?
      // This may be impossible since tasks are scheduled by we don't know
      // their instantaneous queuing status at any given point in time.
    }
  }

  statusReceived(worker: TaskWorker, statuses: TaskResultDesc[]) {
    for (let i = 0; i < statuses.length; i++) {
      const status = statuses[i];
      const id = status[0];
      const task = this.tasks[id];
      const resultController = this.results[id];

      if (task.state === 'scheduled') {
        const workerId = this.workerTaskAssignments[id];
        const worker = this.getWorker(workerId);
        this.freeWorkerTask(worker);
      }

      // current only a fulfillment triggers status updates, so we assume an update fulfills its task:
      task.state = 'completed';
      resultController.completed = true;
      // @TODO: we're dropping the tasks resolved/rejected state on the floor here?

      // [id,status,data] denotes a task with an eager return value (forced/numbers/booleans):
      if (status.length === 3) {
        task.state = 'fulfilled';
        // resolve/reject the status
        resultController.fulfilled = true;
        const op = status[1];
        resultController[op](status[2]);
      }
    }
  }

  addWorker() {
    const worker = new Worker(this.workerUrl, this.workerOptions) as TaskWorker;
    worker.id = ++COUNT;
    worker.pending = 0;
    const callbacks: Record<TaskId, PromiseController> = {};
    worker.onmessage = (e) => {
      const [type, id, data] = e.data;
      const got = `${type}Received`;
      if (this[got]) return this[got](worker, data);
      callbacks[id][type](data);
      delete callbacks[id];
    };
    // Nodejs compat
    // if (worker.addListener) worker.addListener('message', worker.onmessage);
    let q = [];
    const resolved = Promise.resolve();
    function process() {
      worker.postMessage(q);
      q = [];
    }
    worker.call = (method, params) =>
      new Promise(function () {
        const id = ++COUNT;
        callbacks[id] = (arguments as unknown) as PromiseController;
        if (q.push([method, id].concat(params)) === 1) {
          resolved.then(process);
        }
      });
    this.workers.push(worker);
    worker.ready = worker.call('init', [SPECIAL]);
    return worker;
  }

  getWorker(id: WorkerId) {
    for (let i = 0; i < this.workers.length; i++) {
      const worker = this.workers[i];
      if (worker.id == id) return worker;
    }
  }

  getWorkerForTask(taskId: TaskId) {
    const id = this.workerTaskAssignments[taskId];
    for (let i = 0; i < this.workers.length; i++) {
      const worker = this.workers[i];
      if (worker.id == id) return worker;
    }
  }

  getTaskDependencies(args: any[]) {
    const tasks: Task<any>[] = [];
    walkTaskArgs(args, (value) => {
      tasks.push(value);
    });
    return tasks;
  }

  getTaskWorker(taskName: string, args: any[]) {
    const tasks = this.getTaskDependencies(args);
    const usage = {};
    let highest = 0;
    let best: WorkerId;

    for (let i = 0; i < tasks.length; i++) {
      const workerId = this.workerTaskAssignments[tasks[i].id];
      let c = (usage[workerId] = (usage[workerId] || 0) + 1);
      if (c > highest) {
        highest = c;
        best = workerId;
      }
    }

    if (best != null) return this.getWorker(best);
  }

  getNextWorker() {
    const size = this.workers.length;
    if (size === 0) return this.addWorker();
    let best = this.workers[0];
    for (let i = 1; i < size; i++) {
      const worker = this.workers[i];
      if (worker.pending < best.pending) {
        best = worker;
      }
    }
    if (best.pending && size < this.poolSize) {
      return this.addWorker();
    }
    return best;
  }
}

interface Task<T> {
  id: number;
  state: string;
  result: T;

  $$taskIdentifier: string;
  $$result: Promise<T>;
  $$queue: WorkerTaskQueue;
}

class Task<T> {
  cancel() {
    this.$$queue.$$pool.cancel(this.id);
  }
}
Object.defineProperties(Task.prototype, {
  $$taskIdentifier: {
    writable: true,
    enumerable: true
  },
  $$result: {
    writable: true,
  },
  $$queue: {
    writable: true,
  },
  state: {
    writable: true,
    value: 'pending'
  },
  result: {
    get() {
      let c = this.$$result;
      if (!c)
        prop(this, '$$result', (c = this.$$queue.$$pool.getResult(this.id)));
      return c;
    }
  }
});
